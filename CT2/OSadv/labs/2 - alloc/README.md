# Задание 2. Аллокатор

> Дедлайн — **1 ноября**.

В `xv6` реализован только страничный аллокатор — выделять объекты размером меньше страницы неэффективно: на их хранение уйдет целая страница. Из-за этого, все «маленькие» объекты — файловые дескрипторы, структуры процессов и так далее — выделяются статически:

[`kernel/file.c:16-19`](kernel/file.c#L16)
```c
struct {
  struct spinlock lock;
  struct file file[NFILE];
} ftable;
```

Таким образом, количество файлов ограничено переменной `NFILE`.
Сильно увеличивать эту переменную нельзя — большая часть памяти уйдёт на работу операционной системы. Наоборот, если `NFILE` слишком мало, система не сможет поддерживать достаточное количество одновременно открытых файлов.

> `NFILE`, как и многие другие константы, можно найти в файле [`kernel/param.h`](kernel/param.h).

Наша цель — избавиться от этого, заменить аллокатор памяти и выделять файловые структуры динамически. Свой аллокатор писать не потребуется — [buddy allocator](https://en.wikipedia.org/wiki/Buddy_memory_allocation), который мы рассмотрели на семинаре, уже написан. Для этого задания также заменён [`kernel/kalloc.c`](kernel/kalloc.c): там уже инициализируются служебные структуры аллокатора, где хранится информация о свободных и занятых блоках.

> Выполните решение в ветке `alloc`.
> 
> Список файлов, которые можно изменять:
>
> * [`kernel/buddy.c`](kernel/buddy.c)
> * [`kernel/file.h`](kernel/file.h)
> * [`kernel/file.c`](kernel/file.c)
> * [`kernel/param.h`](kernel/param.h)
>
> Остальные файлы изменять нельзя.

## Бонус: Отладчик

В этом задании несложно ошибиться — советуем разобраться с тем, как пользоваться отладчиком.

* [Настройка GDB](gdb.md)

## Часть 1. Использование аллокатора

Используйте для выделения _файловых структур_ новый аллокатор вместо статического массива. Для этого измените файл [`kernel/file.c`](kernel/file.c).

Теперь вам не нужен статический массив файловых структур — он находится в [`kernel/file.c:18`](kernel/file.c#L18). При каждом вызове функции `filealloc` просто выделите место под файл с помощью `bd_malloc`.

Не забудьте освободить используемую память в функции `fileclose`. Ответьте на вопросы и подумайте, как можно улучшить ваш код:
   * Нужен ли теперь `ff`?
   * Нужна ли блокировка в `ftable.lock`? Зачем она вообще используется?

> Чем заполнена область памяти, которую возвращает `bd_malloc`? Что было при использовании статического аллокатора?

После внесения правок в код запустите [`alloctest`](user/alloctest.c). Должен пройти первый тест:

```
$ alloctest
filetest: start
filetest: OK
...
```

Этот тест открывает больше, чем `NFILE` файлов и ожидает, что они все откроются.

> Если вы просто увеличите `NFILE`, тесты не пройдут. Вы можете изменить `kernel/file.c` так, чтобы использовать не `NFILE`, а большую константу, но задание не будет принято, несмотря на пройденные тесты.

Запустите `usertests` и убедитесь, что все тесты проходят. Для быстрой отладки вы можете запустить конкретный тест: `usertests test-name` или только быстрые тесты: `usertests -q`.

> Перед повторным запуском `usertests` возможно вам понадобится вернуть файловую систему в изначальное состояние: `rm fs.img; make qemu`.

## Часть 2. Оптимизация аллокатора

Мы обсуждали на семинаре, что buddy allocator можно оптимизировать следующим образом: сейчас мы для каждого блока храним два бита — флаги «блок занят» (`alloc`) и «блок поделен на две части» (`split`). Фактически, флаг «блок занят» мы используем только в одном месте — когда хотим понять, нужно ли объединить соседние блоки при освобождении.

Давайте попробуем здесь сэкономить 1 бит: вместо флага «блок занят» будем хранить для пары соседних блоков флаг «блок A занят _xor_ блок B занят». Тогда флаг будет установлен, когда занят ровно один из двух блоков, и снят, если оба свободны или оба заняты. Когда мы занимаем или освобождаем блок, достаточно просто инвертировать флаг. При этом, если при освобождении блока бит изменился с 1 на 0, это означает, что до этого у нас из пары был занят ровно один блок, а теперь оба блока свободны. И именно в этом случае мы должны объединить блоки.

Если xv6 управляет объемом памяти размером 128 МБ, то такая оптимизация сохранит нам порядка 1 МБ памяти.

Примените эту оптимизацию для написанного аллокатора и проверьте, что свободной памяти становится больше. Для этого измените файл [`kernel/buddy.c`](kernel/buddy.c).

1. Используйте `bd_print`, чтобы в любом месте увидеть состояние структур аллокатора. Обратите внимание, что если вы поменяете назначение массива `alloc`, то функция будет работать некорректно. Исправлять её необязательно, но это поможет вам отлаживать код.

2. Обратите внимание на то, как аллокатор инициализируется: он считает, что управляет объемом памяти, являющимся степенью двойки — немного большим, чем доступный объем памяти — однако, блок в начале (та часть, где хранятся служебные структуры) и блок в конце (который на самом деле недоступен) помечаются как выделенные.

После выполнения этой части снова запустите `alloctest`. Должны пройти оба теста:

```
$ alloctest
filetest: start
filetest: OK
memtest: start
memtest: OK
```

Второй тест проверяет, сколько памяти занимает ваш аллокатор: программа выделяет всю доступную память и проверяет, что вы сэкономили достаточное количество памяти.

Снова убедитесь, что все тесты из `usertests` проходят.

> **Обратите внимание:** после выполнения тестов у вас **не должно** быть сообщения `Lost some free pages`.

Не забудьте посчитать, сколько времени вы потратите на выполнение домашнего задания. Укажите количество потраченных часов в файле `hours.txt` в корне репозитория. Файл должен содержать **одно натуральное число**. Мы собираем эту информацию для статистики.

## ~~Часть 3*. Использование аллокатора (+6 баллов)~~ *TODO*

> В бонусном задании вы можете изменять все файлы в `kernel/`, которые вы посчитаете нужными.

Примените buddy allocator для структур процессов, аналогично части 1. Ваша система должна уметь аллоцировать произвольное число процессов — столько, сколько влезает в оперативную память.


* Вам придётся внести правки практически во все функции в [`kernel/proc.c`](kernel/proc.c).
* xv6 для работы нужно проходить по всем процессам — подумайте, в какой структуре их удобнее всего хранить, чтобы переписывать как можно меньше кода.
   * Обратите внимание на реализацию buddy allocator — из неё можно подчеркнуть полезные идеи.
* Динамически нужно аллоцировать не только процессы, но и стеки ядра.
   * Физические адреса стеков ядра хранятся в таблице виртуальной памяти (см. [главу 3 книги xv6](https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev3.pdf#chapter.3)). Когда вы выделяете много таких стеков каждый раз всё с новыми и новыми адресами, таблица довольно быстро разрастается. Избегайте этого. Вы можете переиспользовать либо сами стеки, либо их адреса — чтобы попадать в те же страницы.
   * Также можно реализовать функцию `kvmunmap`, которая будет удалять пустые страницы этой таблицы. В этом вам будет проще разобраться, когда вы будете делать третье домашнее задание.
* Не забывайте освобождать ресурсы. Вы можете оставить какую-то память не освобождённой — но только в том случае, если вы дальше её будете использовать.
* Не бойтесь создавать и использовать свои блокировки: будет полезна блокировка на всю вашу структуру в местах, где вы её меняете (например, удаляете процесс из неё или добавляете).
   * Подумайте и о том, безопасно ли читать из изменяющейся структуры (спойлер: скорее всего, нет).

Для этого задания у нас есть два теста. Проверьте, что они работают:

* `forktest` многократно вызывает `fork` и ожидает, что у него получится запустить хотя бы 2 560 процессов
* `reparenttest` проверяет, что при досрочном завершении родительского процесса дочерние становятся детьми `init` и корректно завершаются
  * у него есть два режима работы: `small` аллоцирует 320 процессов параллельно в 10 потоков, `big` занимает всю доступную память

Не забудьте проверить, что `usertests` работают стабильно.

В этой части допускается резервировать память для будущего использования. Это может привести к сообщению `Lost some free pages` при запуске `usertests`. Такое предупреждение допустимо, но вы должны объяснить, каким образом может быть использована данная память в будущем.

> Помните, что задание со звёздочкой сдаётся только вместе с основным.
