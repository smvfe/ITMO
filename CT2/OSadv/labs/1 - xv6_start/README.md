# Задание 1. Введение в xv6

> Дедлайн — **15 октября**.
> 
> К этому моменту необходимо сделать pull request и пройти очное ревью. Если вы не успеете, вы получите меньше баллов за задание.

В этом семестре вы получите шесть домашних заданий. В первой части курса мы будем постепенно дорабатывать и улучшать операционную систему [xv6](https://github.com/mit-pdos/xv6-riscv) — учебную ОС, разрабатываемую с 2006 года в MIT. Для выполнения следующих заданий нам понадобится немного понимать, как работает эта ОС и уметь её собирать.

Наша цель — познакомиться с операционной системой xv6 и подготовить окружение для работы.

> Более подробно разобраться с xv6 поможет книга [R. Cox, F. Kaashoek, R. Morris «xv6: a simple, Unix-like teaching operating system»](https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf) (на английском).
>
> Также, возможно, вам понадобится информация об архитектуре RISC-V, на которой запускается xv6. [Спецификация ISA](https://riscv.org/technical/specifications/) доступна на официальном сайте.

## Часть 1. Инструменты

Установите все необходимые инструменты — тулчейн GCC для сборки под RISC-V и QEMU. Мы составили инструкции под популярные операционные системы:

* [Установка на Linux](tools-linux.md)
* [Установка на macOS](tools-macos.md)
* [Установка на Windows](tools-windows.md)

## Часть 2. Запуск ВМ

Склонируйте этот репозиторий себе на компьютер. Важно не скачать его как ZIP-архив, а именно склонировать.

> Может быть полезно: [Resources to learn Git](https://try.github.io/)

Перейдите в директорию с репозиторием. Для сборки и запуска ОС выполните одну команду:

```
$ make qemu
<...>
xv6 kernel is booting

virtio disk init 0
hart 1 starting
hart 2 starting
init: starting sh
$
```

Вы попали в шелл xv6. Попробуйте выполнить какие-нибудь команды:

```
$ ls
.              1 1 1024
..             1 1 1024
xv6-readme     2 2 1982
xargstest.sh   2 3 93
<...>
$ cat xv6-readme
xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
Version 6 (v6).  xv6 loosely follows the structure and style of v6,
but is implemented for a modern RISC-V multiprocessor using ANSI C.

<...>
```

Чтобы выйти из QEMU, нажмите `Ctrl-A`, затем `X`.

> Обратите внимание, что при перезапуске лишнего вывода перед запуском намного меньше. Это связано с тем, что перекомпилируются только измененные файлы.
>
> Вы можете выполнить `make clean`, чтобы удалить все артефакты сборки и собрать ОС с нуля.

## Общие требования к решениям

**Эти требования обязательны для всех домашних заданий в течение семестра.**

Для решения задания вам необходимо создать отдельную ветку — `intro`. В каждом задании у вас будет своя ветка.

Задание необходимо выполнять именно в этой ветке. Ветка `master` не должна изменяться.

В ветке `intro` должны быть только коммиты с вашим решением поверх того, что уже было в `master` при выдаче задания.

Для отправки решения на проверку отправьте PR. В репозитории должен быть только один открытый PR. Если вы поняли, что вам нужно добавить что-то ещё, просто запушьте дополнительные коммиты в ветку `intro` — они добавятся в PR автоматически.

Загружать файлы в репозиторий через веб-интерфейс GitHub **категорически запрещено**. Такие решения проверяться не будут. Если у вас возникают трудности с Git, рекомендуем вам следующие ресурсы:

- https://learngitbranching.js.org/
- https://gitexercises.fracz.com/

Будет очень здорово, если вы будете разбивать PR на отдельные коммиты, соответствующие частям вашего задания, и давать коммитам читаемые имена. Не бойтесь команды `git rebase -i` — с его помощью можно объединить несколько коммитов, указав опцию `fixup`. Force-пуши разрешены.

Используйте [Google Style Guide](https://google.github.io/styleguide/cppguide.html) — в той части, в которой он актуален для C. Вы можете запустить форматирование и проверки командой `clang-format -Werror */*.c */*.h`.

Также мы просим вас посчитать, сколько времени вы потратите на выполнение домашнего задания, и указать количество потраченных часов в файле `hours.txt` в корне репозитория. Файл должен содержать **одно натуральное число**. Мы собираем эту информацию для статистики.

Перед сдачей в вашем PR должны пройти все обязательные проверки.

## Часть 3. Pingpong

Прежде чем перейти к основной части курса, познакомимся подробнее с xv6 и её системными вызовами. Мы попробуем написать немного user-space кода.

Научитесь обмениваться данными между процессами с помощью специальных FIFO-каналов — [Unix pipes](https://en.wikipedia.org/wiki/Pipeline_(Unix)). Реализуйте программу `user/pingpong.c`. Она должна:

* Создать пайпы для связи двух процессов.
* Форкнуться — создать дочерний процесс.
* Родительский процесс должен отправить сообщение `ping` в дочерний с помощью пайпы.
* Дочерний процесс должен прочитать это сообщение и вывести `<child pid>: got <message>`. После окончания сообщения он должен отправить `pong` родителю.
* Родительский процесс должен прочитать ответ и вывести `<parent pid>: got <message>`.
* Оба процесса должны успешно завершиться.

Советы для выполнения задания:

* Вам понадобится несколько системных вызовов — `pipe`, `fork`, `read`, `write`, `getpid`. Воспользуйтесь утилитой `man`, чтобы узнать, что делают эти вызовы и как ими пользоваться — поведение в xv6 не особо отличается от других Unix-подобных операционных систем.
* Сигнатуры всех доступных системных вызовов приведены в [`user/user.h`](user/user.h).
* Вместо привычных вам `stdlib.h` и `stdio.h` доступна местная стандартная библиотека — [`user/ulib.c`](user/ulib.c), [`printf.c`](user/printf.c) и [`umalloc.c`](user/umalloc.c). Посмотрите на другие программы в директории [`user/`](user/), чтобы понять, как ей пользоваться.
* Добавьте программу в `UPROGS` в `Makefile`, чтобы она скомпилировалась.
* Ваша программа должна быть универсальной: «читающий» процесс не должен знать ничего о длине передаваемой ему строки.
* В программах для xv6 обязательно нужно вызывать `exit(0)` для выхода.

## Часть 4. Dump

В прошлом подзадании мы использовали системные вызовы, например, `pipe` и `fork`. Задача системных вызовов — дать программам из user-space возможность выполнять «привилегированные» команды.

Реализуем новый системный вызов `dump`. Он будет выводить на экран состояние регистров `s2`—`s11` вызываюшего процесса.

Все регистры в xv6 64-битные, однако в рамках данного задания для каждого регистра вам нужно вывести лишь младшую 32-битную часть. Считайте её **знаковым** числом. Значения должны быть выведены в десятеричной системе счисления в одну строку через пробел. В начале строки допишите `[DEBUG] `.

Пример вывода для `s2 = [00000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111]`, `s3 = s4 = ... = s11 = 0`:

```
[DEBUG] -1 0 0 0 0 0 0 0 0 0
```

Чтобы системный вызов был доступен из user-space, добавим в файл [`user/user.h`](user/user.h) объявление функции `dump`, как это сделано для других системных вызовов. В файл [`user/usys.pl`](user/usys.pl) добавьте строку `entry("dump")` — он отвечает за генерацию ассемблерных инструкций для совершения системного вызова.

Теперь реализуем сам системный вызов. Для этого добавьте функцию `dump` в файл [`kernel/proc.c`](kernel/proc.c). Текущий процесс можно получить с помощью функции `myproc`. Структура `proc` содержит поле `trapframe`, в котором и находятся значения всех регистров. Избегайте лишней копипасты при выводе регистров. 

Наконец, отредактируйте файлы [`kernel/syscall.h`](kernel/syscall.h), [`kernel/sysproc.c`](kernel/sysproc.c) и [`kernel/syscall.c`](kernel/syscall.c) так, чтобы появилась возможность вызвать `dump` из user-space. Посмотрите, как реализованы другие вызовы, и сделайте аналогично.

Осталось собрать xv6. Запустите утилиту [`dumptests`](user/dumptests.c) и сравните фактические значения регистров и результат вашего системного вызова.

* Функцию `dump` нужно также определить заголовочном файле в [`kernel/defs.h`](kernel/defs.h).
* Системный вызов должен возвращать 0 при успешном завершении, и код ошибки в остальных случаях. Наш системный вызов всегда завершается успешно.

## Часть 5*. Dump2 (+3 балла) DONE

> Это — необязательная часть. Если вы выполните её, то получите бонусные баллы. Помните, что необязательная часть сдаётся только вместе со всем заданием — досдать её отдельно не получится.

Мы бы могли использовать системный вызов `dump`, чтобы написать собственный отладчик. Однако, у него есть два недостатка. Во-первых, он выводит значение регистров на экран, и мы не можем обработать эти значения в user-space. Во-вторых, он позволяет узнать значения регистров только у текущего процесса, что делает невозможным отладку другого процесса. Напишем ещё один системный вызов, чтобы исправить эти недостатки — `dump2`. У этого вызова будет три аргумента:

* `int pid` — номер процесса, для которого запрашивается значение регистра
* `int register_num` — номер регистра, число от 2 до 11
* `uint64 *return_value` — адрес, по которому необходимо вернуть значение

Обратите внимание, что в целях безопасности регистры процесса может смотреть только сам процесс и его родитель.

В этом системном вызове, в отличие от `dump`, вам понадобится корректно обрабатывать и возвращать ошибки:

* Верните `-1`, если вызвавший процесс не имеет прав смотреть требуемый регистр
* Верните `-2`, если процесса с таким идентификатором не существует
* Верните `-3`, если передан некорректный номер регистра
* Верните `-4`, если не удалось записать данные по переданному адресу

Полезные советы:

* Аргументы в системные вызовы передаются немного иначе, нежели в обычные функции. Посмотрите на другие системные вызовы, чтобы понять, как получать аргументы из user-space.
* Вы не можете записать данные напрямую по адресу `*return_value` — это виртуальный адрес в user-space, и использовать его в kernel-space невозможно. Вам поможет функция `copyout`.

Запустите [`dump2tests`](user/dump2tests.c). Проверка происходит автоматически.
